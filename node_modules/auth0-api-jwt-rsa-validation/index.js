var LRU     = require('lru-cache');
var request = require('request');
var _       = require('lodash');

var secretsCacheOptions = {
  // 5 M unicode points => ~10 MB
  max: 1024 * 1024 * 5,
  length: function (s) { return s.length; },
  maxAge: 1000 * 60 * 5
};

var secretsCache = LRU(secretsCacheOptions);

function certToPEM (cert) {
  cert = cert.match(/.{1,64}/g).join('\n');
  cert = "-----BEGIN CERTIFICATE-----\n" + cert;
  cert = cert + "\n-----END CERTIFICATE-----\n";
  return cert;
}

module.exports = function (opt) {
  opt           = opt || {};
  opt.strictSSL = typeof opt.strictSSL === 'undefined' ? true : opt.strictSSL;

  return function secretCallback (req, header, payload, cb){
    var cacheKey = payload.iss + '|' + payload.aud ;
    var cachedSecret = secretsCache.get(cacheKey);

    if (cachedSecret) {
      return cb(null, cachedSecret);
    }

    switch (header.alg) {
      case 'RS256': // asymmetric keys
        var url = payload.iss + '.well-known/jwks.json';

        request.get(url, { json: true, strictSSL: opt.strictSSL }, function (err, resp, jwks) {
          if (err) {
            return cb(err);
          }
          if (resp.statusCode !== 200) {
            return cb(new Error('Failed to obtain JWKS from ' + payload.iss));
          }

          // TODO: Make this more resilient to JWKS and tokens that don't indicate a kid.
          var key = _.find(jwks.keys, function(key) {
            return key.kid == header.kid;
          });

          if (!key) {
            return cb(new Error('Failed to obtain signing key used by ' + payload.iss));
          }
          // TODO: Make this more resilient to keys that don't include x5c
          var publicKey = certToPEM(key.x5c[0]);
          secretsCache.set(cacheKey, publicKey);
          return cb(null, publicKey);
        });
        break;
      default:
        return cb(new Error('Unsupported JWT algorithm: ' + header.alg));
    }
  };
}
